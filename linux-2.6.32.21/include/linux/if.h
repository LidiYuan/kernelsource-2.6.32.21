/*
 * INET		An implementation of the TCP/IP protocol suite for the LINUX
 *		operating system.  INET is implemented using the  BSD Socket
 *		interface as the means of communication with the user level.
 *
 *		Global definitions for the INET interface module.
 *
 * Version:	@(#)if.h	1.0.2	04/18/93
 *
 * Authors:	Original taken from Berkeley UNIX 4.3, (c) UCB 1982-1988
 *		Ross Biro
 *		Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
 *
 *		This program is free software; you can redistribute it and/or
 *		modify it under the terms of the GNU General Public License
 *		as published by the Free Software Foundation; either version
 *		2 of the License, or (at your option) any later version.
 */
#ifndef _LINUX_IF_H
#define _LINUX_IF_H

#include <linux/types.h>		/* for "__kernel_caddr_t" et al	*/
#include <linux/socket.h>		/* for "struct sockaddr" et al	*/
#include <linux/compiler.h>		/* for "__user" et al           */

#define	IFNAMSIZ	16
#define	IFALIASZ	256
#include <linux/hdlc/ioctl.h>

//设备接口状态常亮定义
/* Standard interface flags (netdevice->flags). */
#define	IFF_UP		0x1		/* interface is up		接口正在运行*/
#define	IFF_BROADCAST	0x2		/* broadcast address valid	有效的广播地址集*/
#define	IFF_DEBUG	0x4		/* turn on debugging		内部调试标志*/
#define	IFF_LOOPBACK	0x8		/* is a loopback net		这是自环接口*/
#define	IFF_POINTOPOINT	0x10		/* interface is has p-p link	这是点到点的链路接口*/
#define	IFF_NOTRAILERS	0x20		/* avoid use of trailers 不使用网络跟踪功能		避免使用trailer */
#define	IFF_RUNNING	0x40		/* interface RFC2863 OPER_UP	设备正处于运行状态 同IFF_UP	资源已分配*/
#define	IFF_NOARP	0x80		/* no ARP protocol		该设备不使用ARP协议完成IP地址到硬件地址的映射. ifconfig eth1 -arp:禁止arp*/
#define	IFF_PROMISC	0x100		/* receive all packets		接口为杂凑(promiscuous)模式*/
#define	IFF_ALLMULTI	0x200		/* receive all multicast packets接收所有多播(multicast)报文*/

//一个主设备管理多个从设备,一般主设备是软件上的设备,而从设备是真正的硬件网卡设备,当发送数据包的时候,主设备
//根据某种策略选择一个从设备完成实际的发送 主设备net_device的flags设置IFF_MASTER 从设备设置IFF_SLAVE
#define IFF_MASTER	0x400		/* master of a load balancer 	主负载平衡群*/
#define IFF_SLAVE	0x800		/* slave of a load balancer	从负载平衡群*/

#define IFF_MULTICAST	0x1000		/* Supports multicast 该设备支持多播*/

#define IFF_PORTSEL	0x2000          /* can set media type		可以通过ifmap选择介质(media)类型*/
#define IFF_AUTOMEDIA	0x4000		/* auto media select active	自动选择介质*/
#define IFF_DYNAMIC	0x8000		/* dialup device with changing addresses接口关闭时丢弃地址*/

#define IFF_LOWER_UP	0x10000		/* driver signals L1 up		*/
#define IFF_DORMANT	0x20000		/* driver signals dormant	*/

#define IFF_ECHO	0x40000		/* echo sent packets		*/

#define IFF_VOLATILE	(IFF_LOOPBACK|IFF_POINTOPOINT|IFF_BROADCAST|IFF_ECHO|\
		IFF_MASTER|IFF_SLAVE|IFF_RUNNING|IFF_LOWER_UP|IFF_DORMANT)

/* Private (from user) interface flags (netdevice->priv_flags). */
#define IFF_802_1Q_VLAN 0x1             /* 802.1Q VLAN device.          */
#define IFF_EBRIDGE	0x2		/* Ethernet bridging device.	*/
#define IFF_SLAVE_INACTIVE	0x4	/* bonding slave not the curr. active */
#define IFF_MASTER_8023AD	0x8	/* bonding master, 802.3ad. 	*/
#define IFF_MASTER_ALB	0x10		/* bonding master, balance-alb.	*/
#define IFF_BONDING	0x20		/* bonding master or slave	*/
#define IFF_SLAVE_NEEDARP 0x40		/* need ARPs for validation	*/
#define IFF_ISATAP	0x80		/* ISATAP interface (RFC4214)	*/
#define IFF_MASTER_ARPMON 0x100		/* bonding master, ARP mon in use */
#define IFF_WAN_HDLC	0x200		/* WAN HDLC device		*/
#define IFF_XMIT_DST_RELEASE 0x400	/* dev_hard_start_xmit() is allowed to
					 * release skb->dst
					 */

#define IF_GET_IFACE	0x0001		/* for querying only */
#define IF_GET_PROTO	0x0002

/* For definitions see hdlc.h */
#define IF_IFACE_V35	0x1000		/* V.35 serial interface	*/
#define IF_IFACE_V24	0x1001		/* V.24 serial interface	*/
#define IF_IFACE_X21	0x1002		/* X.21 serial interface	*/
#define IF_IFACE_T1	0x1003		/* T1 telco serial interface	*/
#define IF_IFACE_E1	0x1004		/* E1 telco serial interface	*/
#define IF_IFACE_SYNC_SERIAL 0x1005	/* can't be set by software	*/
#define IF_IFACE_X21D   0x1006          /* X.21 Dual Clocking (FarSite) */

/* For definitions see hdlc.h */
#define IF_PROTO_HDLC	0x2000		/* raw HDLC protocol		*/
#define IF_PROTO_PPP	0x2001		/* PPP protocol			*/
#define IF_PROTO_CISCO	0x2002		/* Cisco HDLC protocol		*/
#define IF_PROTO_FR	0x2003		/* Frame Relay protocol		*/
#define IF_PROTO_FR_ADD_PVC 0x2004	/*    Create FR PVC		*/
#define IF_PROTO_FR_DEL_PVC 0x2005	/*    Delete FR PVC		*/
#define IF_PROTO_X25	0x2006		/* X.25				*/
#define IF_PROTO_HDLC_ETH 0x2007	/* raw HDLC, Ethernet emulation	*/
#define IF_PROTO_FR_ADD_ETH_PVC 0x2008	/*  Create FR Ethernet-bridged PVC */
#define IF_PROTO_FR_DEL_ETH_PVC 0x2009	/*  Delete FR Ethernet-bridged PVC */
#define IF_PROTO_FR_PVC	0x200A		/* for reading PVC status	*/
#define IF_PROTO_FR_ETH_PVC 0x200B
#define IF_PROTO_RAW    0x200C          /* RAW Socket                   */

/* RFC 2863 operational status */
enum {
	IF_OPER_UNKNOWN,
	IF_OPER_NOTPRESENT,
	IF_OPER_DOWN,
	IF_OPER_LOWERLAYERDOWN,
	IF_OPER_TESTING,
	IF_OPER_DORMANT,
	IF_OPER_UP,
};

/* link modes */
enum {
	IF_LINK_MODE_DEFAULT,
	IF_LINK_MODE_DORMANT,	/* limit upward transition to dormant */
};

/*
 *	Device mapping structure. I'd just gone off and designed a 
 *	beautiful scheme using only loadable modules with arguments
 *	for driver options and along come the PCMCIA people 8)
 *
 *	Ah well. The get() side of this is good for WDSETUP, and it'll
 *	be handy for debugging things. The set side is fine for now and
 *	being very small might be worth keeping for clean configuration.
 */
//用于设置设备的基本信息
struct ifmap 
{
	unsigned long mem_start;//硬件读写缓冲区首地址
	unsigned long mem_end; //硬件读写缓冲区尾地址
	unsigned short base_addr; //本设备使用的IO端口地址
	unsigned char irq;	//本设备使用的中断号
	unsigned char dma; //本设备使用的DMA通道号
	unsigned char port;//对用device结构的if_port字段
	/* 3 bytes spare */
};

struct if_settings
{
	unsigned int type;	/* Type of physical device or protocol */
	unsigned int size;	/* Size of the data allocated by the caller */
	union {
		/* {atm/eth/dsl}_settings anyone ? */
		raw_hdlc_proto		__user *raw_hdlc;
		cisco_proto		__user *cisco;
		fr_proto		__user *fr;
		fr_proto_pvc		__user *fr_pvc;
		fr_proto_pvc_info	__user *fr_pvc_info;

		/* interface settings */
		sync_serial_settings	__user *sync;
		te1_settings		__user *te1;
	} ifs_ifsu;
};

/*
 * Interface request structure used for socket
 * ioctl's.  All interface ioctl's must have parameter
 * definitions which begin with ifr_name.  The
 * remainder may be interface specific.
 */
//每个ifreq表示一个设备的接口信息
struct ifreq 
{
#define IFHWADDRLEN	6
	union
	{
		char	ifrn_name[IFNAMSIZ];		/* if name, e.g. "en0" */
	} ifr_ifrn;
	
	union {
		struct	sockaddr ifru_addr; //设备IP地址
		struct	sockaddr ifru_dstaddr;//接口目的端地址,只使用在点对点连接中
		struct	sockaddr ifru_broadaddr;//接口广播地址
		struct	sockaddr ifru_netmask;//地址掩码
		struct  sockaddr ifru_hwaddr;//设备对用的硬件地址
		
		short	ifru_flags;//获取设置SIOCGIFFLAGS, SIOCSIFFLAGS  设备对应的标志字段值
						/*值包含:IFF_UP*/
		int	ifru_ivalue;
		int	ifru_mtu;	//设备对用的最大传输单元
		struct  ifmap ifru_map;//用户设置获取设备的基本信息
		char	ifru_slave[IFNAMSIZ];	/* Just fits the size */
		char	ifru_newname[IFNAMSIZ];
		void __user *	ifru_data;
		struct	if_settings ifru_settings;
	} ifr_ifru;

	
};

#define ifr_name	ifr_ifrn.ifrn_name	/* interface name 	*/
#define ifr_hwaddr	ifr_ifru.ifru_hwaddr	/* MAC address 		*/
#define	ifr_addr	ifr_ifru.ifru_addr	/* address		*/
#define	ifr_dstaddr	ifr_ifru.ifru_dstaddr	/* other end of p-p lnk	*/
#define	ifr_broadaddr	ifr_ifru.ifru_broadaddr	/* broadcast address	*/
#define	ifr_netmask	ifr_ifru.ifru_netmask	/* interface net mask	*/
#define	ifr_flags	ifr_ifru.ifru_flags	/* flags		*/
#define	ifr_metric	ifr_ifru.ifru_ivalue	/* metric		*/
#define	ifr_mtu		ifr_ifru.ifru_mtu	/* mtu			*/
#define ifr_map		ifr_ifru.ifru_map	/* device map		*/
#define ifr_slave	ifr_ifru.ifru_slave	/* slave device		*/
#define	ifr_data	ifr_ifru.ifru_data	/* for use by interface	*/
#define ifr_ifindex	ifr_ifru.ifru_ivalue	/* interface index	*/
#define ifr_bandwidth	ifr_ifru.ifru_ivalue    /* link bandwidth	*/
#define ifr_qlen	ifr_ifru.ifru_ivalue	/* Queue length 	*/
#define ifr_newname	ifr_ifru.ifru_newname	/* New name		*/
#define ifr_settings	ifr_ifru.ifru_settings	/* Device/proto settings*/

/*
 * Structure used in SIOCGIFCONF request.
 * Used to retrieve interface configuration
 * for machine (useful for programs which
 * must know all networks accessible).
 */
//用于信息获取
struct ifconf 
{
	int	ifc_len;			/* size of buffer	缓冲区长度*/
	union 
	{
		char __user *ifcu_buf;//信息为一个ifreq结构数组
		struct ifreq __user *ifcu_req;
	} ifc_ifcu;	//存储具体的信息，信息以ifreq结构为单元
};
#define	ifc_buf	ifc_ifcu.ifcu_buf		/* buffer address	*/
#define	ifc_req	ifc_ifcu.ifcu_req		/* array of structures	*/

#endif /* _LINUX_IF_H */
