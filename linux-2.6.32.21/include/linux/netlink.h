#ifndef __LINUX_NETLINK_H
#define __LINUX_NETLINK_H

#include <linux/socket.h> /* for sa_family_t */
#include <linux/types.h>


/*NETLINK_ROUTE分为多个消息族
LINK(网络接口)
ADDR(网络地址)
ROUTE(路由选择消息)
NEIGH(邻居子系统消息)
RULE(策略路由规则)
QDISC(排队规则)
TCLASS(流量类型)
ACTION(数据包操作API)
NEIGHTBL(邻接表)
ADDRLABEL(地址标记)
*/
#define NETLINK_ROUTE		0	/* 路由其中 NETLINK_ROUTE 类型提供了网络地址发生变化的消息		
                                 在 rtnetlink_net_init 中使用 */
                                                             
#define NETLINK_UNUSED		1	/* Unused number				*/
#define NETLINK_USERSOCK	2	/* Reserved for user mode socket protocols 	*/
#define NETLINK_FIREWALL	3	/* Firewalling hook				*/
#define NETLINK_INET_DIAG	4	/* INET socket monitoring			*/
#define NETLINK_NFLOG		5	/* netfilter/iptables ULOG */
#define NETLINK_XFRM		6	/* ipsec 表示IPsec子系统*/
#define NETLINK_SELINUX		7	/* SELinux event notifications */
#define NETLINK_ISCSI		8	/* Open-iSCSI */
#define NETLINK_AUDIT		9	/* auditing 审计子系统*/
#define NETLINK_FIB_LOOKUP	10	
#define NETLINK_CONNECTOR	11  
#define NETLINK_NETFILTER	12	/* netfilter subsystem */
#define NETLINK_IP6_FW		13  
#define NETLINK_DNRTMSG		14	/* DECnet routing messages */
#define NETLINK_KOBJECT_UEVENT	15	/* Kernel messages to userspace 用于内核事件发送到应用层*/
#define NETLINK_GENERIC		16   //通用套接字类型
/* leave room for NETLINK_DM (DM Events) */
#define NETLINK_SCSITRANSPORT	18	/* SCSI Transports */
#define NETLINK_ECRYPTFS	19

#define MAX_LINKS 32		

struct net;

struct sockaddr_nl
{
	sa_family_t	nl_family;	/* AF_NETLINK	*/
	unsigned short	nl_pad;		/* zero		零*/
	__u32		nl_pid;		/* port ID	端口号 netlink套接字的单播地址 对于内核netlink套接字 该值为0；
	                        */
    __u32		nl_groups;	/* multicast groups mask 组播组掩码*/
};

//netlink消息头，数据紧跟在头的后面
struct nlmsghdr
{
	__u32		nlmsg_len;	/* 包括消息头在内的消息总长度 */
	__u16		nlmsg_type;	/*消息类型 基本消息类型如NLMSG_ERROR,可以添加自己的消息类型*/
	__u16		nlmsg_flags;	/* 用于修改消息类型行为 NLM_F_ACK*/
	__u32		nlmsg_seq;	/* 序列号 用于排列消息 可选使用*/
	__u32		nlmsg_pid;	/* 发送端口ID 对于内核发送的消息 此为0,对于从应用层发送的消息此值可设置为进程PID*/
};
/*
---------------------------
       消息长度           |
---------------------------
  消息类型 |   标志       |
---------------------------
       序列号             |
---------------------------
       端口ID             |
---------------------------
      载荷数据

*/

/* Flags values */

#define NLM_F_REQUEST	1   /* It is request message. 	消息为请求消息*/
#define NLM_F_MULTI		2	/* 消息由多部分组成,消息的长度通常不超过一页 因为大型消息被分成许多小行消息,每条消息都设置NLM_F_MULTI,
                               但最后一条设置NLMSG_DONE */
#define NLM_F_ACK		4	/* 希望接收方使用ACK对消息进行应答,ACK消息是由方法netlink_ack发送的 */
#define NLM_F_ECHO		8	/* Echo this request 	回应当前请求	*/

/* Modifiers to GET request */
#define NLM_F_ROOT	0x100	/* specify tree	root	指定树根*/
#define NLM_F_MATCH	0x200	/* return all matching	返回所有匹配的条目*/
#define NLM_F_ATOMIC	0x400	/* atomic GET	以放弃此标志	*/
#define NLM_F_DUMP	(NLM_F_ROOT|NLM_F_MATCH) //检索有关表/条目的信息

/* Modifiers to NEW request */
#define NLM_F_REPLACE	0x100	/* Override existing	覆盖既有条目	*/
#define NLM_F_EXCL	0x200	/* Do not touch, if it exists	保留既有条目不变*/
#define NLM_F_CREATE	0x400	/* Create, if it does not exist	创建条目*/
#define NLM_F_APPEND	0x800	/* Add to end of list	在列表末尾添加条目	*/

/*
   4.4BSD ADD		NLM_F_CREATE|NLM_F_EXCL
   4.4BSD CHANGE	NLM_F_REPLACE

   True CHANGE		NLM_F_CREATE|NLM_F_REPLACE
   Append		NLM_F_CREATE
   Check		NLM_F_EXCL
 */

#define NLMSG_ALIGNTO	4
#define NLMSG_ALIGN(len) ( ((len)+NLMSG_ALIGNTO-1) & ~(NLMSG_ALIGNTO-1) )
#define NLMSG_HDRLEN	 ((int) NLMSG_ALIGN(sizeof(struct nlmsghdr)))
#define NLMSG_LENGTH(len) ((len)+NLMSG_ALIGN(NLMSG_HDRLEN))

#define NLMSG_SPACE(len) NLMSG_ALIGN(NLMSG_LENGTH(len))



#define NLMSG_NEXT(nlh,len)	 ((len) -= NLMSG_ALIGN((nlh)->nlmsg_len), \
				  (struct nlmsghdr*)(((char*)(nlh)) + NLMSG_ALIGN((nlh)->nlmsg_len)))
#define NLMSG_OK(nlh,len) ((len) >= (int)sizeof(struct nlmsghdr) && \
			   (nlh)->nlmsg_len >= sizeof(struct nlmsghdr) && \
			   (nlh)->nlmsg_len <= (len))


//将指针指向真正的数据
#define NLMSG_DATA(nlh)  ((void*)(((char*)nlh) + NLMSG_LENGTH(0)))
//获得数据的长度			   
#define NLMSG_PAYLOAD(nlh,len) ((nlh)->nlmsg_len - NLMSG_SPACE((len)))


#define NLMSG_NOOP		0x1	/* Nothing.		不执行任何操作,必须将消息丢弃*/
#define NLMSG_ERROR		0x2	/* Error		发生了错误*/
#define NLMSG_DONE		0x3	/* End of a dump	由多部分组成的消息的末尾*/
#define NLMSG_OVERRUN		0x4	/* Data lost		缓冲区溢出通知*/
//小于此消息类型用于保留 用于控制消息
#define NLMSG_MIN_TYPE		0x10	/* < 0x10: reserved control messages */

//netlink错误消息格式
struct nlmsgerr
{
	int		error;
	struct nlmsghdr msg;
};

#define NETLINK_ADD_MEMBERSHIP	1  //加入组播组
#define NETLINK_DROP_MEMBERSHIP	2 //退出组播组
#define NETLINK_PKTINFO		    3
#define NETLINK_BROADCAST_ERROR	4
#define NETLINK_NO_ENOBUFS	    5

struct nl_pktinfo
{
	__u32	group;
};

#define NET_MAJOR 36		/* Major 36 is reserved for networking 						*/

enum {
	NETLINK_UNCONNECTED = 0,
	NETLINK_CONNECTED,
};

/*
 *  <------- NLA_HDRLEN ------> <-- NLA_ALIGN(payload)-->
 * +---------------------+- - -+- - - - - - - - - -+- - -+
 * |        Header       | Pad |     Payload       | Pad |
 * |   (struct nlattr)   | ing |                   | ing |
 * +---------------------+- - -+- - - - - - - - - -+- - -+
 *  <-------------- nlattr->nla_len -------------->
 */
//netlink属性头
struct nlattr
{
	__u16           nla_len;//属性的长度 单位为字节
	__u16           nla_type;//属性的类型 可能的取值包括 NLA_U32(32位无符号整数)
};

/*
 * nla_type (16 bits)
 * +---+---+-------------------------------+
 * | N | O | Attribute Type                |
 * +---+---+-------------------------------+
 * N := Carries nested attributes
 * O := Payload stored in network byte order
 *
 * Note: The N and O flag are mutually exclusive.
 */
#define NLA_F_NESTED		(1 << 15)
#define NLA_F_NET_BYTEORDER	(1 << 14)
#define NLA_TYPE_MASK		~(NLA_F_NESTED | NLA_F_NET_BYTEORDER)

#define NLA_ALIGNTO		4
#define NLA_ALIGN(len)		(((len) + NLA_ALIGNTO - 1) & ~(NLA_ALIGNTO - 1))
#define NLA_HDRLEN		((int) NLA_ALIGN(sizeof(struct nlattr)))

#ifdef __KERNEL__

#include <linux/capability.h>
#include <linux/skbuff.h>

static inline struct nlmsghdr *nlmsg_hdr(const struct sk_buff *skb)
{
	return (struct nlmsghdr *)skb->data;
}

struct netlink_skb_parms
{
	struct ucred		creds;		/* Skb credentials	*/
	__u32			pid;
	__u32			dst_group;
	kernel_cap_t		eff_cap;
	__u32			loginuid;	/* Login (audit) uid */
	__u32			sessionid;	/* Session id (audit) */
	__u32			sid;		/* SELinux security id */
};

#define NETLINK_CB(skb)		(*(struct netlink_skb_parms*)&((skb)->cb))
#define NETLINK_CREDS(skb)	(&NETLINK_CB((skb)).creds)


extern void netlink_table_grab(void);
extern void netlink_table_ungrab(void);

extern struct sock *netlink_kernel_create(struct net *net,
					  int unit,unsigned int groups,
					  void (*input)(struct sk_buff *skb),
					  struct mutex *cb_mutex,
					  struct module *module);
extern void netlink_kernel_release(struct sock *sk);
extern int __netlink_change_ngroups(struct sock *sk, unsigned int groups);
extern int netlink_change_ngroups(struct sock *sk, unsigned int groups);
extern void __netlink_clear_multicast_users(struct sock *sk, unsigned int group);
extern void netlink_clear_multicast_users(struct sock *sk, unsigned int group);
extern void netlink_ack(struct sk_buff *in_skb, struct nlmsghdr *nlh, int err);
extern int netlink_has_listeners(struct sock *sk, unsigned int group);
extern int netlink_unicast(struct sock *ssk, struct sk_buff *skb, __u32 pid, int nonblock);
extern int netlink_broadcast(struct sock *ssk, struct sk_buff *skb, __u32 pid,
			     __u32 group, gfp_t allocation);
extern void netlink_set_err(struct sock *ssk, __u32 pid, __u32 group, int code);
extern int netlink_register_notifier(struct notifier_block *nb);
extern int netlink_unregister_notifier(struct notifier_block *nb);

/* finegrained unicast helpers: */
struct sock *netlink_getsockbyfilp(struct file *filp);
int netlink_attachskb(struct sock *sk, struct sk_buff *skb,
		      long *timeo, struct sock *ssk);
void netlink_detachskb(struct sock *sk, struct sk_buff *skb);
int netlink_sendskb(struct sock *sk, struct sk_buff *skb);

/*
 *	skb should fit one page. This choice is good for headerless malloc.
 *	But we should limit to 8K so that userspace does not have to
 *	use enormous buffer sizes on recvmsg() calls just to avoid
 *	MSG_TRUNC when PAGE_SIZE is very large.
 */
#if PAGE_SIZE < 8192UL
#define NLMSG_GOODSIZE	SKB_WITH_OVERHEAD(PAGE_SIZE)
#else
#define NLMSG_GOODSIZE	SKB_WITH_OVERHEAD(8192UL)
#endif

#define NLMSG_DEFAULT_SIZE (NLMSG_GOODSIZE - NLMSG_HDRLEN)


struct netlink_callback
{
	struct sk_buff		*skb;
	const struct nlmsghdr	*nlh;
	int			(*dump)(struct sk_buff * skb,
					struct netlink_callback *cb);
	int			(*done)(struct netlink_callback *cb);
	int			family;
	long			args[6];
};

struct netlink_notify
{
	struct net *net;
	int pid;
	int protocol;
};

static __inline__ struct nlmsghdr *
__nlmsg_put(struct sk_buff *skb, u32 pid, u32 seq, int type, int len, int flags)
{
	struct nlmsghdr *nlh;
	int size = NLMSG_LENGTH(len);

	nlh = (struct nlmsghdr*)skb_put(skb, NLMSG_ALIGN(size));
	nlh->nlmsg_type = type;
	nlh->nlmsg_len = size;
	nlh->nlmsg_flags = flags;
	nlh->nlmsg_pid = pid;
	nlh->nlmsg_seq = seq;
	if (!__builtin_constant_p(size) || NLMSG_ALIGN(size) - size != 0)
		memset(NLMSG_DATA(nlh) + len, 0, NLMSG_ALIGN(size) - size);
	return nlh;
}

#define NLMSG_NEW(skb, pid, seq, type, len, flags) \
({	if (unlikely(skb_tailroom(skb) < (int)NLMSG_SPACE(len))) \
		goto nlmsg_failure; \
	__nlmsg_put(skb, pid, seq, type, len, flags); })

#define NLMSG_PUT(skb, pid, seq, type, len) \
	NLMSG_NEW(skb, pid, seq, type, len, 0)

extern int netlink_dump_start(struct sock *ssk, struct sk_buff *skb,
			      const struct nlmsghdr *nlh,
			      int (*dump)(struct sk_buff *skb, struct netlink_callback*),
			      int (*done)(struct netlink_callback*));


#define NL_NONROOT_RECV 0x1
#define NL_NONROOT_SEND 0x2
extern void netlink_set_nonroot(int protocol, unsigned flag);

#endif /* __KERNEL__ */

#endif	/* __LINUX_NETLINK_H */
